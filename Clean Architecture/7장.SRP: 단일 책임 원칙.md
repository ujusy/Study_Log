# 7장. SRP: 단일 책임 원칙

- 액터: 해당 변경을 요청하는 한 명 이상의 사람들
- SRP: 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야한다.
- 모듈: 소스파일 / 단순히 함수와 데이터 구조로 구성된 응집된 집합

- 단일 액터를 책임지는 코드를 함께 묶어주는 힘: 응딥성

### SRP 위반 사례

1. 우발적 중복

CEO, COO, CTO 보고를 위해 사용하는 메서드들이 `Emplolyee` 클래스에 구성되어있는 경우

세 개의 메서드들 단일 클래스에 배치하면서 세 액터(CEO, COO, CTO)가 결합되었다.

이 결합으로 인해서 CTO 가 결정한 조치가 COO 가 의존하는 무언가에 영향을 줄 수 있다.

내부적으로 CTO 팀과 COO 팀이 코드 중복을 없애기 위해 업무시간을 계산하는 알고리즘을 `regularHours` 라는 메서드에 넣었다고 가정해보자.

이후 CTO팀은 업무시간을 계산하는 방법이 바뀌어 해당 메서드를 변경하게 되었을 때 개발자는 요청된 사항을 적용하고 CTO 팀의 요구사항에 맞게
동작하는지 테스트하고 배포된다.
이 때 COO 팀은 이런 변경사항을 인지하지 못하고 추후 집계가 잘못되는 문제를 겪는다.

2. 병합

각 팀에서 작업을 할 때 하나의 클래스인 `Employee` 클래스를 동시에 변경한다. 이런 경우 결국 충돌하고 결과적으로 병합이 발생한다.

**해결 방법**

- 데이터와 메서드를 분리하는 방식
  - 아무런 메서드가 없는 간단한 데이터 구조인 `EmployeeData` 클래스를 만들어 세 개의 클래스가 공유하도록 수정
  - 세 개의 클래스는 서로의 존재를 몰라 우연한 중복을 피할 수 있다.
- 퍼사드 패턴 사용
  - 서브시스템의 인터페이스 집합에 대한 하나의 상위 수준 인터페이스를 정의하는 패턴
  
---
- 단일 책임 원칙은 메서드와 클래스 수준의 원칙
- 컴포넌트 수준: 공통 폐쇄 원칙
- 아키텍처 수준: 아키텍처 경계의 생성을 책임지는 변경의 축
