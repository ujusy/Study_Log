# 리팩터링 ch 3.11 - 3.24

https://refactoring.guru/ -> * 참고 *  링크는 리팩토링 관련해서 예시나 ~하기 에 대한 기본 설명을 잘 해둔 사이트다. 

- **3.11 기본형 집착**

  : 문제에 알맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하지 않고 금액을 숫자형으로 계산하거나, 물리량을 계산할 대 단위를 무시하고 처리하는 경우가 많다.

  - 기본형을 객체로 바꾸기
  - 타입 코드를 서브클래스로 바꾸기, 조건부 로직을 다형성으로 바꾸기
  - 클래스 추출하기, 매개변수 객체 만들기

- **3.12 반복되는 switch 문**

  -  switch 문이 문제가 되는 이유? 
    - 조건절을 하나 추가할 때마다 다른 switch 문들도 모두 찾아서 함께 수정해야하기 때문
  - 음..switch와 if-else 를 언제 사용하는가에 대한 고민을 예전에 했던 적이 있었다. 사실 아직도 명확하게 어떤 경우에 switch 문을 사용하고 어떤 경우에 if-else 문을 사용해야하는지 잘 모르겠다. 근데 개발하다보면 자연스럽게 이 부분은switch 문을 써야지 이렇게 되는거 같기는하다.. 순수 객체 지향을 추구한다면 모두 다형성으로 빼야하긴 하겠지만..

- **3.13 반복문**

  - 마틴 파울러님께서는 반복문을 탐탁지 않게 여겼다고한다..
  - 최근에는 일급 함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용하여 반복문을 제거한다.
  - `filter`, `map`과 같은 파이프라인을 사용하여 로직파악을 더 수월하게 할 수 있다.

- **3.14 성의 없는 요소**
  - 실질적으로 메서드가 하나뿐인 클래스 등 어떠한 사정으로 인해 다른 메서드를 추가할 계획이었지만 그렇지 못한 경우
  - 리팩터링을 거치면서 간소화가 된 경우 
    - 이러한 경우들은 함수 인라인하기, 클래스 인라인하기 등을 사용하여 해결한다.
    - 상속을 사용한 경우라면 계층 합치기를 적용하여 해결한다.
  
- **3.15 추측성 일반화**
  - '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드
    - 오..최근에 언젠간 사용할거야 하면서 작성한 코드가 있는데 굉장히 찔리는 문장이다.. ㅜ
  -  하는 일이 거의 없는 추상 클래스인 경우: 계층 합치기
  - 의미 없이 위임하는 코드: 함수 인라인, 클래스 인라인하기
  - 본문에서 사용되지 않는 매개변수: 함수 선언 바꾸기
  - 죽은 코드 제거하기..
  
- **3.16 임시 필드**
  - 간혹 특정 상황에서는 값이 설정되는 필드를 가진 클래스가 있다.
  - 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는게 보통이다. -> 음.. 이부분 공감이 잘 안된다.. 왜 당연히 모든 필드가 채워져있을거라고 생각하는거지..?
  - 사용자가 쓰이지 않는 것처럼 모이는 필드가 존재하는 이유를 파악하느라 머리를 싸매게 된다.
    - 덩그러니 떨어져 있는 필드들: 클래스 추출하기
    - 함수 옳기기로 임시 필드들에 관련한 코드를 모조리 새 클래스에 몰아넣는다.
    - 특이 케이스 추가하기: 필드들이 유효하지 않을 때를 위한 대안 클래스 만들어 제거
  - 이 부분 공감이 잘 안된다..저렇게 유효하지 않은 경우는 예외처리를 안한게 아닐까..?
  
- **3.17 메시지 체인**
  - 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
  - 위임 숨기기로 해결
    - getter나 메서드를 새로 만들어 중간에 호출하던 객체들을 숨긴다.

- **3.18 중개자**
  - 과도한 위임을 제거하자는 내용이다. 중개자 제거하기로 표현하고있다.
  
- **3.19 내부자 거래**
  - 불필요하게 결합, 숨겨져 데이터를 공유하는 로직등의 경우를 의미하는 거 같다.
    - 함수 옮기기, 필드 옮기기로 떼어놓아서 사적으로 처리한다.
    - 위임 숨기기 혹은 제3의 모듈을 만들어 중간자 역할을 하게한다.
    - 상속 구조에서 불필요한 결합이 일어나는 경우 서브 클래스를 위임으로 바꾸기, 슈퍼 클래스를 위임으로 바꾸기를 통해 해결하자.
  
- **3.20 거대한 클래스**
  - 하나의 클래스가 많은 일을 하려다 보면 필드 수가 상당히 늘어나고 방대해진다. -> 중복코드 많이 발생
  - 클래스 추출하기(한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출)
  - 클래스가 거대해지면 공통 로직을 추출하여 슈퍼 클래스 혹은 클래스로 추출하기 등을 사용해 나누면 좋을 것 같다.
  
- **3.21 서로 다른 인터페이스의 대안 클래스들**

  - 클래스를 교체하여 사용하기 위해서는 인터페이스가 같아야한다. 
    - 함수 선언 바꾸기로 메서드 시그니처를 일치시킨다. 그래도 힘들다면 함수 옮기기를 이용하여 인터페이스가 같아질 때까지 클래스로 밀어넣자.

- **3.22 데이터 클래스**

  - 불변 데이터일 경우: 게터 통하지 않고 필드 자체를 공개
  - 클래스에 public 필드가 있는 경우: 레코드 캡슐화하기
  - 변경하면 안되는 클래스: 세터 제거하기
  - 게터나 세터를 사용하는 메서드가 있는 경우
    - 함수 옮기기로 데이터 클래스 내부로 메서드를 옮기기
    - 메서드를 옮기기가 힘들다면 함수 추출하기로 옮길 수 있는 부분만 별도 메서드를 뽑아낸다.
    - 직접 클래스에 구현을 해보니 setter와 getter을 사용하지 않고 외부에서 사용할 수 있는 방법이 무엇인지 잘 모르겠다.
    - 기본적으로 setter 사용을 지양하라는 의견은 많이 들었기에 지양하려하지만 getter의 경우에는 그냥 생성해서 사용하고있다..
    - tda 원칙에 관해 공부도 해보았는데 이론적으로 이해는 됐지만 실제 프로젝트에서 사용해보고 작동시켜봐야 더 잘 이해될 것 같다.

- **3.23 상속 포기**

  - 서브클래스는 부모로부터 메서드와 데이터를 물려받는다. 
  - 만약 부모의 유산을 관심 있는 몇 개만 받고 끝내고싶다면?
    - 같은 계층에 서브클래스 하나를 만들고 메서드 내리기, 필드 내리기를 활용해 물려받지 않을 부모 코드를 모조리 새로 만든 서브 클래스로 넘긴다. -> 부모에는 공통된 부분만 남는다. 

- **3.24 주석**

  - 주석은 향기라고 표현한다.
  - 지금까지 나는 주석 == 좋지 않은 스타일 이라고 생각해왔는데 오히려 해당 코드가 어떠한 목적으로 사용되는지 작성해두는 것을 좋은 것 같다.왜냐면 내가 작성한 코드는 읽어봤을 때 무슨 목적인지 알지만 이 레거시를 보는 다음 개발자는 이해하지 못할 확률이 높기때문이다...
