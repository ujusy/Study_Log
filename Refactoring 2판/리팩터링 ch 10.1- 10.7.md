# 리팩터링 ch 10.1 - 10.7

- 복잡한 조건문: 조건문 분해하기

- 논리적인 조합 다음기: 중복 조건식 통합하기

- 함수의 핵심 로직에 본격적으로 들어가기 앞서 무언가를 검사해야할 때: 중첩 조건문을 보호 구문으로 바꾸기
- 똑같은 분기 로직의 중복: 조건부 로직을 다형성으로 바꾸기
- `null`과 같은 특이 케이스 처리: 특이 케이스 추가하기
- 프로그램 상태를 확인하고 그 결과게 따라 다르게 동작하는 경우: 어서션 추가하기
- 제어 플래그를 이용해 코드 동작 흐름을 변경하는 코드: 제어 플래그를 탈출문으로 바꾸기

## 10.1 조건문 분해하기

복잡한 조건부 로직 -> 프로그램 복잡 + 읽기 어려워진다.

- 거대한 코드 블록이 주어지면 코드를 부위별로 분해.
- 코드 덩어리들을 각 덩어리의 의도를 살린 이름의 함수 호출로 변경
  - 전체적인 의도가 더 확실히 드러난다.



```javascript
if (!isDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd)) 
  charge = quantity * plan.summerRate;
else 
  charge = quantity * plan.regularRate + plan.regularServiceCharge;
```



- 조건 부분을 별도 함수로 추출

  ```javascript
  if (summer())
  	charge = quantity * plan.summerRate;
  else
    charge = quantity * plan.regularRate + plan.regularServiceCharge;
  
  function summer() {
    return !isDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);
  }
  ```



## 10.2 조건식 통합하기

 조건부 코드 통합하는 중요한 이유 두 가지

- 여러 조각으로 나뉜 조각들을 하나로 통합함으로써 하려는 일이 명확해진다.
- 이 작업이 함수 추출하기까지 이어질 가능성이 높다.
  - 복잡한 조건식을 함수로 추출하면 코드의 의도가 훨씬 분명하게 드러나는 경우가 많다.



## 10.3 중첩 조건문을 보호 구문으로 바꾸기

조건문은 주로 두가지 형태

- 참인 경로와 거짓인 경로 모두 정상 작동으로 이어지는 형태
  - if - else 절을 사용
- 한쪽만 정상인 형태
  - 비정상 조건을 if에서 검사한다.
  - 이러한 검사 형태를 `보호 구문` 이라고한다.

```javascript
function payAmount(employee) {
  let result;
  if(employee.isSeparated) { // 퇴사한 직원인가?
    result = {amount: 0, reasonCode: "SEP"};
  } 
  else {
    if(employee.isRetired) { // 은퇴한 직원인가?
      result = {amount: 0, reasonCode: "RET"};
    }
    else {
      // 급여 계산 로직
      lorem.ipsum(dolor.sitAmet);
      consectetur(adipiscing).elit();
      sed.do.eiusmod = empor.incididunt.ut(labore) && dolore(magna.aliqua);
      ut.enim.ad(minim.veniam);
      result = someFinalComputation();
    }
  }
  return result;
}
```



- 최상위 조건부터 보호 구문으로 변경

  ```javascript
  function payAmount(employee) {
    let result;
    if(employee.isSeparated) return {amount: 0, reasonCode: "SEP"}; // 보호구문으로 변경
    if(employee.isRetired) return {amount: 0, reasonCode: "RET"}; // 보호구문 변경
    
      // 급여 계산 로직
      lorem.ipsum(dolor.sitAmet);
      consectetur(adipiscing).elit();
      sed.do.eiusmod = empor.incididunt.ut(labore) && dolore(magna.aliqua);
      ut.enim.ad(minim.veniam);
      result = someFinalComputation();
  
  
    return result;
  }
  ```



## 10.4 조건부 로직을 다형성으로 바꾸기

- 조건부 로직을 직관적으로 구조화할 방법
  - 클래스와 다형성을 이용하여 분리

1. 다형성 동작을 표현하는 클래스들이 아직 없다면 만들어준다. 이왕이면 적합한 인스턴스를 알아서 만들어 반환하는 팩터리 함수도 함께 만든다.
2. 호출하는 코드에서 팩터리 함수를 사용하게 한다.
3. 조건부 로직 함수를 슈퍼클래스로 옮긴다.
4. 서브클래스 중 하나를 선택한다. 서브클래스에서 슈퍼클래스의 조건부 로직 메서드를 오버라이드한다. 조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 서브클래스 메서드로 복사한 다음 적절히 수정한다.
5. 같은 방식으로 각 조건절을 해당 서브클래스에서 메서드로 구현한다.
6. 슈펴클래스 메서드에는 기본 동작 부분만 남긴다. 혹은 슈퍼클래스가 추상 클래스여야한다면, 이 메서드를 추상으로 선언하거나 서브클래스에서 처리해야 함을 알리는 에러를 던진다. 



```javascript
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]));
}

function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));
}
 
function plumage(bird) {
  ...
}

function airSpeedVelocity(bird) { 
  ...
}
```

- `airSpeedVelocity` , `plumage` 를 bird 라는 클래스로 묶어보자

  ```javascript
  function plumage(bird) {
    return new Bird(bird).plumage;
  }
  
  function airSpeedVelocity(bird) {
    return new Bird(bird).airSpeedVelocity;
  }
  
  class Bird {
    consturctor(birdObject) {
      object.assign(this, birdObject);
    }
    
    get plumage() {
      ...
    }
    
    get airSpeedVelocity() {
      ...
    }
  }

- 종별 서브클래스를 만든다. 적합한 서브클래스의 인스턴스를 만들어줄 팩토리 함수도 만들어주자. 객체를 얻을 때 팩터리 함수를 사용하도록 한다.

  ```javascript
  function plumage(bird) {
    return createBird(bird).plumage;
  }
  
  function airSpeedVelocity(bird) {
    return createBird(bird).airSpeedVelocity;
  }
  ```

  

## 10.5 특이 케이스 추가하기



## 10.6 어서션 추가하기



## 10.7 제어 플래그를 탈출문으로 바꾸기

